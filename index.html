<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Constelaciones - Camila Sosa Villada (mejorado)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* --- Styles (preservo estética original) --- */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;font-family:"EB Garamond",serif;background:#0c0a09;color:#111}

    #stage{position:fixed;inset:0;display:grid;place-items:center}
    .aurora{position:absolute;inset:0;
      background: radial-gradient(1200px 800px at 20% 30%, #ffecd2 0%, transparent 60%),
                  radial-gradient(900px 700px at 80% 70%, #ffd1ff 0%, transparent 55%),
                  radial-gradient(900px 700px at 70% 20%, #d0f0ff 0%, transparent 55%),
                  radial-gradient(700px 600px at 30% 80%, #ffe2c7 0%, transparent 60%);
      filter: blur(40px) saturate(130%) contrast(105%);
      animation:hue 18s linear infinite alternate; opacity:.7; pointer-events:none}
    @keyframes hue{0%{transform:scale(1);filter:hue-rotate(0deg) blur(40px) saturate(130%) contrast(105%)}100%{transform:scale(1.05);filter:hue-rotate(40deg) blur(44px) saturate(140%) contrast(110%)}}
    #particles{position:absolute;inset:0;pointer-events:none;opacity:.85;mix-blend-mode:screen}
    /* Two network layers are in same container to preserve single visual area */
    #mynetwork{position:absolute;inset:0;box-shadow:inset 0 0 120px rgba(0,0,0,.6);cursor:grab}
    #mynetwork:active{cursor:grabbing}

    /* Overlay (glass) */
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:6vh 5vw;z-index:30;
      background: radial-gradient(1200px 800px at 50% 50%, rgba(255,255,255,.06) 0%, rgba(0,0,0,.65) 60%, rgba(0,0,0,.85) 100%);
      backdrop-filter: blur(8px) saturate(110%);animation:overlayIn 300ms ease forwards}
    @keyframes overlayIn{from{opacity:0}to{opacity:1}}
    .card{width:min(1100px,92vw);max-height:82vh;overflow:auto;padding:clamp(18px,3.2vw,36px);
      background:rgba(255,250,240,.12);border:1px solid rgba(217,166,115,.45);border-radius:20px;color:#faf4ec;box-shadow:0 10px 40px rgba(0,0,0,.55),inset 0 0 0 1px rgba(255,255,255,.06)}
    .title{font-size:clamp(28px,4.2vw,46px);color:#ffe7c7;margin-bottom:14px}
    .media{display:block;width:min(280px,60%);max-width:40vw;border-radius:14px;border:2px solid rgba(217,166,115,.55);box-shadow:0 8px 30px rgba(0,0,0,.35);margin:6px 0 18px 0}
    .text{font-size:clamp(18px,2.4vw,22px);line-height:1.65;color:#fff6eb;text-align:justify;white-space:pre-wrap}
    .close{position:sticky;top:0;float:right;transform:translate(10px,-10px);border:1px solid rgba(217,166,115,.6);background:rgba(255,248,240,.12);color:#ffe7c7;padding:8px 12px;border-radius:999px;cursor:pointer}
    .notes{margin-top:18px;padding-top:14px;border-top:1px solid rgba(255,224,196,.4);font-size:clamp(16px,2vw,20px);color:rgba(255,243,230,.92);line-height:1.6;white-space:pre-wrap}
    .hint{position:fixed;bottom:18px;left:18px;z-index:40;font-size:14px;color:rgba(255,236,214,.9);background:rgba(20,16,14,.45);border:1px solid rgba(217,166,115,.4);border-radius:999px;padding:8px 12px;pointer-events:none}

    /* Editor panel (kept) */
    .editor-panel{position:fixed;top:18px;right:18px;z-index:50;display:flex;flex-direction:column;gap:12px;padding:14px 18px;max-width:min(420px,92vw);background:rgba(18,14,12,.78);border:1px solid rgba(217,166,115,.4);border-radius:16px;box-shadow:0 12px 45px rgba(0,0,0,.4);backdrop-filter:blur(10px) saturate(120%)}
    .editor-panel h2{font-size:18px;margin-bottom:6px;color:#ffe7c7}
    .editor-panel label{display:block;font-size:14px;margin-bottom:4px;color:rgba(255,236,214,.85)}
    .editor-panel input,.editor-panel textarea,.editor-panel select{width:100%;padding:8px 10px;margin-bottom:10px;border-radius:10px;border:1px solid rgba(217,166,115,.35);background:rgba(255,248,240,.08);color:#fff6eb;resize:vertical}
    .editor-panel button{align-self:flex-start;padding:8px 14px;border-radius:999px;border:1px solid rgba(217,166,115,.55);background:rgba(255,248,240,.16);color:#ffe7c7;cursor:pointer}
    .editor-panel .panel-content{display:none;flex-direction:column;gap:14px;max-height:70vh;overflow-y:auto;padding-right:4px}
    .editor-panel .panel-content.active{display:flex}
    .editor-panel .message{font-size:13px;color:rgba(255,236,214,.9);margin-top:4px}

    /* small responsive tweaks */
    @media (max-width:720px){.card{padding:18px}}
  </style>
</head>
<body>
  <!-- Editor panel -->
  <div class="editor-panel" id="editorPanel" aria-label="Herramientas de edición">
    <button id="toggleEditor" aria-expanded="false">✦ Editar Red</button>
    <div class="panel-content" id="editorContent">
      <div class="section">
        <h2>Constelación</h2>
        <label for="constellationSelect">Seleccionar constelación</label>
        <select id="constellationSelect"></select>
        <div class="message">Crear nodo en la constelación seleccionada.</div>
      </div>

      <div class="section">
        <h2>Editar nodo</h2>
        <p class="message" id="selectionMessage">Selecciona un nodo para editarlo.</p>
        <label for="nodeLabel">Título</label>
        <input id="nodeLabel" type="text" placeholder="Nombre del nodo" />
        <label for="nodeInfo">Descripción</label>
        <textarea id="nodeInfo" placeholder="Texto del nodo"></textarea>
        <label for="nodeNotes">Notas (visible en ficha)</label>
        <textarea id="nodeNotes" placeholder="Notas adicionales"></textarea>
        <label><input id="nodePhysics" type="checkbox" /> Afectado por física (inercia/tensión)</label>
        <label><input id="nodeFixed" type="checkbox" /> Bloqueado (no se mueve)</label>
        <div style="display:flex;gap:8px;">
          <button id="saveNode">Guardar cambios</button>
          <button id="deleteNode">Eliminar nodo</button>
        </div>
        <p class="message" id="nodeMessage"></p>
      </div>

      <div class="section">
        <h2>Conexiones</h2>
        <p class="message" id="connectionHelp">Modo: presioná "Agregar conexión", luego clic en primer nodo → luego en segundo.</p>
        <div style="display:flex;gap:8px;">
          <button id="addConnection">Agregar conexión</button>
          <button id="removeConnection">Quitar conexión</button>
        </div>
        <p class="message" id="connectionMessage"></p>
      </div>

      <div class="section">
        <h2>Nuevo nodo</h2>
        <label for="newNodeLabel">Título</label>
        <input id="newNodeLabel" type="text" placeholder="Nombre del nuevo nodo" />
        <label for="newNodeInfo">Descripción</label>
        <textarea id="newNodeInfo" placeholder="Texto del nuevo nodo"></textarea>
        <label for="newNodeNotes">Notas (opcional)</label>
        <textarea id="newNodeNotes" placeholder="Notas para la ficha"></textarea>
        <label for="newNodePhysics"><input id="newNodePhysics" type="checkbox" /> Afectado por física</label>
        <label for="newNodeFixed"><input id="newNodeFixed" type="checkbox" /> Bloqueado</label>
        <div style="display:flex;gap:8px;">
          <button id="createNode">Crear nodo</button>
          <button id="newConstellation">➕ Crear constelación nueva</button>
        </div>
        <p class="message" id="createMessage"></p>
      </div>

      <div class="section">
        <h2>Guardar / Reset</h2>
        <div style="display:flex;gap:8px;">
          <button id="exportJSON">Exportar JSON</button>
          <button id="importJSON">Importar JSON</button>
          <button id="resetBtn">Resetear</button>
        </div>
        <p class="message" id="storageMessage"></p>
      </div>
    </div>
  </div>

  <!-- Stage -->
  <div id="stage">
    <div class="aurora" aria-hidden="true"></div>
    <canvas id="particles"></canvas>
    <div id="mynetwork" role="application" aria-label="Visualización de red"></div>
    <div class="dim-overlay" id="dim"></div>
  </div>

  <!-- Overlay card -->
  <div id="overlay" aria-hidden="true">
    <article class="card" id="card">
      <button class="close" id="closeBtn" aria-label="Cerrar">✕</button>
      <h1 class="title" id="title"></h1>
      <img src="portada.jpg" alt="Portada" class="media" />
      <div class="text" id="text"></div>

      <label style="margin-top:12px;color:#ffe7c7">Editar notas</label>
      <textarea id="notesInput" style="width:100%;min-height:120px;margin-top:8px;border-radius:10px;padding:10px;background:rgba(255,248,240,0.06);color:#fff6eb"></textarea>
      <div style="margin-top:10px;display:flex;gap:8px;">
        <button id="saveNotesOverlay" class="close">Guardar notas</button>
        <button id="closeOverlayBtn" class="close">Cerrar</button>
      </div>

      <div class="notes" id="notes" hidden></div>
    </article>
  </div>

  <div class="hint">clic en un nodo · rueda para zoom · arrastrar para mover</div>

  <script>
  /*****************************************************************
   *  Constelaciones mejoradas (single vis.Network) - explicación:
   *  - Usamos una sola vis.Network para evitar conflictos de clicks/overlay.
   *  - Cada nodo tiene propiedad `constellation` para agrupar.
   *  - Cuando se crea nodo en otra constelación, lo ubicamos con un offset X grande
   *    para separarlo visualmente y evitar "atracción" inmediata.
   *  - Motor: barnesHut con parámetros para movimiento "estelar".
   *  - Cada nodo puede tener `physics: true/false` y `fixed` para controlar inercia.
   *****************************************************************/

  // ---------- DATOS INICIALES (recuperados del original) ----------
  const initialConfs = ["Camila Sosa Villada", "Travestismo Cuántico"];
  let STORAGE_KEY = "camila_vanguardia_graph_v4";

  // original nodes (kept main texts). I keep same IDs for backward compatibility.
  let nodes_data = [
    { id: 1, label: "Desierto", info: `el desierto se configura como una imagen densa y multivalente ...`, constellation: "Camila Sosa Villada" },
    { id: 2, label: "Deseo", info: `No se presenta como algo puramente erótico ni como motor...`, constellation: "Camila Sosa Villada" },
    { id: 3, label: "Materialismo Travesti", info: `En las partes que componen el libro —especialmente...`, constellation: "Camila Sosa Villada" },
    { id: 4, label: "Monstruosidad", info: `ser monstruo es vivir bajo amenaza, bajo asedio...`, constellation: "Camila Sosa Villada" },
    { id: 6, label: "Memoria", info: `campo afectivo y material en el que se inscriben los cuerpos...`, constellation: "Camila Sosa Villada" },
    { id: 7, label: "Bitácora", info: `Terminé, una parte. Ahora queda realizar un trenzado...`, constellation: "Camila Sosa Villada" }
  ];

  let edges_data = [
    { from: 1, to: 2 },
    { from: 1, to: 3 },
    { from: 3, to: 6 },
    { from: 6, to: 7 },
    { from: 4, to: 1 },
    { from: 3, to: 4 },
    { from: 2, to: 3 }
  ];

  // ---------- util: load saved state ----------
  function loadState() {
    try {
      const s = localStorage.getItem(STORAGE_KEY);
      if (!s) return null;
      return JSON.parse(s);
    } catch (e) {
      console.warn("No se pudo leer estado:", e);
      return null;
    }
  }

  function saveState(payload) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    } catch (e) {
      console.warn("No se pudo guardar estado:", e);
    }
  }

  // ---------- datasets (vis) ----------
  // each node will have: id, label, info, notes, constellation, physics (true/false), fixed (object or false), x,y optional
  const saved = loadState();
  if (saved) {
    // restore structure from saved
    nodes_data = saved.nodes || nodes_data;
    edges_data = saved.edges || edges_data;
    // ensure every node has constellation (fallback)
    nodes_data = nodes_data.map(n => ({ ...n, constellation: n.constellation || initialConfs[0], physics: (n.physics !== false) }));
  } else {
    // enrich initial nodes: set defaults (physics true)
    nodes_data = nodes_data.map(n => ({ ...n, constellation: n.constellation || initialConfs[0], physics: true }));
  }

  const container = document.getElementById("mynetwork");
  const nodes = new vis.DataSet(nodes_data.map(n => {
    // convert fixed boolean to vis format
    const copy = { ...n };
    if (copy.fixed === true) copy.fixed = { x: true, y: true };
    return copy;
  }));
  const edges = new vis.DataSet(edges_data);

  // ---------- funzione per posizionare initial nodes in groups ----------
  // If node has no x,y, place nodes of second constelation offset to right for separation.
  function ensureGroupSeparation() {
    // determine constellations present
    const confs = Array.from(new Set(nodes.get().map(n => n.constellation || initialConfs[0])));
    // assign bounding centers by index
    const width = window.innerWidth;
    const centers = {};
    confs.forEach((c, idx) => {
      // spread across horizontally
      const cx = (0.15 + 0.7 * (idx / Math.max(1, confs.length - 1))) * width;
      centers[c] = { x: cx, y: window.innerHeight / 2 };
    });
    // For each node without x,y set approximate around its constellation center with jitter
    nodes.get().forEach(n => {
      if (n.x == null || n.y == null) {
        const c = n.constellation || confs[0];
        const jitter = 180 + Math.random() * 120;
        const angle = Math.random() * Math.PI * 2;
        const x = centers[c].x + Math.cos(angle) * jitter;
        const y = centers[c].y + Math.sin(angle) * jitter;
        nodes.update({ id: n.id, x, y });
      }
    });
  }

  // Call now to set positions for newly created nodes if needed
  ensureGroupSeparation();

  // ---------- network options (barnesHut tuned) ----------
  const options = {
    autoResize: true,
    nodes: {
      shape: "dot",
      size: 18,
      font: { size: 18, color: "#fff6eb", face: "EB Garamond" },
      color: {
        background: "#fff1e3",
        border: "#ffb97a",
        highlight: { background: "#ffe0c4", border: "#ffd0a6" }
      },
      borderWidth: 2,
      shadow: { enabled: true, color: "rgba(255,180,120,.5)", size: 18, x: 0, y: 0 }
    },
    edges: {
      color: { color: "rgba(255,200,160,.85)", highlight: "#ffd6b3" },
      width: 2,
      smooth: { type: "continuous" },
      shadow: { enabled: true, color: "rgba(0,0,0,.35)", size: 8, x: 0, y: 0 }
    },
    physics: {
      enabled: true,
      solver: "barnesHut",
      barnesHut: {
        gravitationalConstant: -2000,   // negative to slightly repel globally (large magnitude -> stronger repulsion)
        centralGravity: 0.002,         // tiny central pull so groups don't drift off screen
        springLength: 220,
        springConstant: 0.02,
        damping: 0.28,
        avoidOverlap: 0.6
      },
      stabilization: { enabled: false }
    },
    interaction: {
      hover: true,
      tooltipDelay: 120,
      zoomView: true,
      dragView: true,
      dragNodes: true,
      multiselect: false,
      selectConnectedEdges: true
    },
    layout: { improvedLayout: false }
  };

  const network = new vis.Network(container, { nodes, edges }, options);

  /***********************
   * Persistence helpers *
   ***********************/
  function persistAll() {
    const payload = {
      nodes: nodes.get().map(n => ({
        id: n.id, label: n.label, info: n.info, notes: n.notes || "",
        constellation: n.constellation || initialConfs[0],
        physics: (n.physics !== false),
        fixed: !!(n.fixed && (n.fixed.x === true || n.fixed === true)),
        x: (n.x != null ? n.x : undefined),
        y: (n.y != null ? n.y : undefined)
      })),
      edges: edges.get().map(e => ({ from: e.from, to: e.to, id: e.id }))
    };
    saveState(payload);
  }

  // Save on changes
  nodes.on("add", persistAll);
  nodes.on("update", persistAll);
  nodes.on("remove", persistAll);
  edges.on("add", persistAll);
  edges.on("remove", persistAll);

  // Also save after drag end positions
  network.on("dragEnd", params => {
    if (params.nodes && params.nodes.length) {
      const positions = network.getPositions(params.nodes);
      params.nodes.forEach(id => {
        const p = positions[id];
        // update node x,y to persist where it's left
        nodes.update({ id, x: p.x, y: p.y });
      });
      persistAll();
    }
  });

  // ---------- Glow idle (gentle) ----------
  let pulse = 0;
  setInterval(() => {
    pulse = (pulse + 1) % 360;
    const factor = 18 + Math.sin(pulse * Math.PI / 180) * 1.6;
    network.setOptions({ nodes: { ...options.nodes, size: factor } });
  }, 90);

  // ---------- UI wiring ----------
  const toggleEditorBtn = document.getElementById("toggleEditor");
  const editorContent = document.getElementById("editorContent");
  const constellationSelect = document.getElementById("constellationSelect");

  // node edit fields
  const nodeLabelInput = document.getElementById("nodeLabel");
  const nodeInfoInput = document.getElementById("nodeInfo");
  const nodeNotesInput = document.getElementById("nodeNotes");
  const nodePhysicsInput = document.getElementById("nodePhysics");
  const nodeFixedInput = document.getElementById("nodeFixed");
  const selectionMessage = document.getElementById("selectionMessage");
  const saveNodeBtn = document.getElementById("saveNode");
  const deleteNodeBtn = document.getElementById("deleteNode");
  const nodeMessage = document.getElementById("nodeMessage");

  // create fields
  const newNodeLabelInput = document.getElementById("newNodeLabel");
  const newNodeInfoInput = document.getElementById("newNodeInfo");
  const newNodeNotesInput = document.getElementById("newNodeNotes");
  const newNodePhysics = document.getElementById("newNodePhysics");
  const newNodeFixed = document.getElementById("newNodeFixed");
  const createNodeBtn = document.getElementById("createNode");
  const newConstBtn = document.getElementById("newConstellation");
  const createMessage = document.getElementById("createMessage");

  // connection
  const addConnectionBtn = document.getElementById("addConnection");
  const removeConnectionBtn = document.getElementById("removeConnection");
  const connectionMessage = document.getElementById("connectionMessage");

  // overlay elements
  const overlay = document.getElementById("overlay");
  const titleEl = document.getElementById("title");
  const textEl = document.getElementById("text");
  const notesEl = document.getElementById("notes");
  const notesInput = document.getElementById("notesInput");
  const saveNotesOverlayBtn = document.getElementById("saveNotesOverlay");
  const closeOverlayBtn = document.getElementById("closeOverlayBtn");
  const closeBtn = document.getElementById("closeBtn");

  // export/import/reset
  const exportBtn = document.getElementById("exportJSON");
  const importBtn = document.getElementById("importJSON");
  const resetBtn = document.getElementById("resetBtn");
  const storageMessage = document.getElementById("storageMessage");

  // hint toggles
  toggleEditorBtn.addEventListener("click", () => {
    const active = editorContent.classList.toggle("active");
    toggleEditorBtn.setAttribute("aria-expanded", active ? "true" : "false");
  });

  // populate constellation select with existing groups from nodes and initial ones
  function refreshConstellationOptions() {
    const existing = new Set(nodes.get().map(n => n.constellation || initialConfs[0]));
    // ensure initialConfs present
    initialConfs.forEach(c => existing.add(c));
    // create options
    constellationSelect.innerHTML = "";
    Array.from(existing).forEach(c => {
      const o = document.createElement("option");
      o.value = c; o.textContent = c;
      constellationSelect.appendChild(o);
    });
  }
  refreshConstellationOptions();

  // selection state
  let activeNodeId = null;

  function updateEditorForSelection(nodeId) {
    if (!nodeId) {
      selectionMessage.textContent = "Selecciona un nodo para editarlo.";
      nodeLabelInput.value = "";
      nodeInfoInput.value = "";
      nodeNotesInput.value = "";
      nodePhysicsInput.checked = true;
      nodeFixedInput.checked = false;
      saveNodeBtn.disabled = true;
      deleteNodeBtn.disabled = true;
      return;
    }
    const n = nodes.get(nodeId);
    activeNodeId = nodeId;
    selectionMessage.textContent = `Editando nodo ID ${nodeId}`;
    nodeLabelInput.value = n.label || "";
    nodeInfoInput.value = n.info || "";
    nodeNotesInput.value = n.notes || "";
    nodePhysicsInput.checked = (n.physics !== false);
    nodeFixedInput.checked = !!(n.fixed && (n.fixed.x === true || n.fixed === true));
    saveNodeBtn.disabled = false;
    deleteNodeBtn.disabled = false;
  }

  network.on("selectNode", params => {
    const nodeId = params.nodes[0];
    updateEditorForSelection(nodeId);
    // open overlay
    if (!connectMode.active) {
      openOverlay(nodeId, params.pointer?.DOM);
    }
  });

  saveNodeBtn.addEventListener("click", () => {
    if (!activeNodeId) return;
    const label = nodeLabelInput.value.trim();
    const info = nodeInfoInput.value.trim();
    if (!label || !info) { nodeMessage.textContent = "Completa título y descripción"; setTimeout(()=>nodeMessage.textContent="",2200); return; }
    const notes = nodeNotesInput.value.trim();
    const physics = nodePhysicsInput.checked;
    const fixedChecked = nodeFixedInput.checked;

    const update = { id: activeNodeId, label, info, notes, physics };
    if (fixedChecked) {
      // get position and fix there
      const pos = network.getPositions([activeNodeId])[activeNodeId];
      update.fixed = { x: true, y: true };
      update.x = pos.x; update.y = pos.y;
    } else {
      update.fixed = false;
      // leave x,y as they are (they'll be used by physics)
    }
    nodes.update(update);
    persistAll();
    nodeMessage.textContent = "Nodo guardado ✓";
    setTimeout(()=>nodeMessage.textContent="",1500);
  });

  deleteNodeBtn.addEventListener("click", () => {
    if (!activeNodeId) return;
    const id = activeNodeId;
    nodes.remove({ id });
    // remove edges
    edges.get().forEach(e => { if (e.from === id || e.to === id) edges.remove(e.id); });
    persistAll();
    updateEditorForSelection(null);
  });

  // ---------- Overlay open/close and editing notes ----------
  let overlayNodeId = null;
  function openOverlay(nodeId, pointer) {
    const n = nodes.get(nodeId);
    if (!n) return;
    overlayNodeId = nodeId;
    titleEl.textContent = n.label || "";
    textEl.textContent = n.info || "";
    notesInput.value = n.notes || "";
    notesEl.textContent = n.notes || "";
    notesEl.hidden = !n.notes;
    // set spotlight coords
    if (pointer) {
      document.getElementById("dim").style.setProperty("--x", pointer.x + "px");
      document.getElementById("dim").style.setProperty("--y", pointer.y + "px");
    }
    document.getElementById("dim").classList.add("show");
    overlay.style.display = "flex";
    overlay.setAttribute("aria-hidden","false");
  }
  function closeOverlay() {
    overlay.style.display = "none";
    overlayNodeId = null;
    document.getElementById("dim").classList.remove("show");
  }

  saveNotesOverlayBtn.addEventListener("click", () => {
    if (!overlayNodeId) return;
    const newNotes = notesInput.value.trim();
    nodes.update({ id: overlayNodeId, notes: newNotes });
    persistAll();
    notesEl.textContent = newNotes;
    notesEl.hidden = !newNotes;
    saveNotesOverlayBtn.textContent = "Guardado ✓";
    setTimeout(()=> saveNotesOverlayBtn.textContent = "Guardar notas",800);
  });
  closeOverlayBtn.addEventListener("click", closeOverlay);
  closeBtn.addEventListener("click", closeOverlay);

  // ---------- Create node (in constellation) ----------
  createNodeBtn.addEventListener("click", () => {
    const label = newNodeLabelInput.value.trim();
    const info = newNodeInfoInput.value.trim();
    if (!label || !info) { createMessage.textContent = "Completa título y descripción"; setTimeout(()=>createMessage.textContent="",2000); return; }
    const notes = newNodeNotesInput.value.trim();
    const physics = newNodePhysics.checked;
    const fixedChecked = newNodeFixed.checked;
    const constellation = constellationSelect.value || initialConfs[0];

    // id incremental safe
    const newId = Math.max(...(nodes.getIds().map(Number)), 0) + 1;

    // position: place near constellation center with offset to visually separate groups
    // compute constellation centers
    const consts = Array.from(new Set(nodes.get().map(n => n.constellation)));
    const idx = (consts.indexOf(constellation) >= 0) ? consts.indexOf(constellation) : consts.length;
    const width = window.innerWidth;
    const height = window.innerHeight;
    const centerX = (0.15 + 0.7 * (idx / Math.max(1, Math.max(1,consts.length)-1))) * width;
    const centerY = height / 2;
    const jitter = 40 + Math.random() * 120;
    const angle = Math.random() * Math.PI * 2;
    const x = centerX + Math.cos(angle) * jitter;
    const y = centerY + Math.sin(angle) * jitter;

    const nodeObj = { id: newId, label, info, notes, constellation, physics: !!physics };
    if (fixedChecked) nodeObj.fixed = { x: true, y: true }, nodeObj.x = x, nodeObj.y = y;
    else nodeObj.x = x, nodeObj.y = y;

    nodes.add(nodeObj);
    persistAll();

    newNodeLabelInput.value = ""; newNodeInfoInput.value = ""; newNodeNotesInput.value = "";
    createMessage.textContent = `Nodo ${newId} creado en "${constellation}"`;
    setTimeout(()=>createMessage.textContent="",1600);

    // refresh select options if new constellation created earlier
    refreshConstellationOptions();
  });

  // ---------- Create new constellation button ----------
  newConstBtn.addEventListener("click", () => {
    const name = prompt("Nombre de la nueva constelación:");
    if (!name) return;
    // add to selection and reselect
    // create small invisible placeholder node? not necessary; we just add option
    const opt = document.createElement("option"); opt.value = name; opt.textContent = name;
    constellationSelect.appendChild(opt);
    constellationSelect.value = name;
    setTimeout(()=>{ setMessage(storageMessage, `Constelación "${name}" creada.`); }, 50);
  });

  function setMessage(el, txt, timeout=2000) {
    el.textContent = txt;
    if (!txt) return;
    setTimeout(()=>{ if (el.textContent === txt) el.textContent = ""; }, timeout);
  }

  // ---------- Connection mode (click A then B) ----------
  let connectMode = { active: false, remove: false, source: null };

  addConnectionBtn.addEventListener("click", () => {
    connectMode = { active: true, remove: false, source: null };
    setMessage(connectionMessage, "Modo CONEXIÓN: clic en primer nodo → clic en segundo nodo", 5000);
  });

  removeConnectionBtn.addEventListener("click", () => {
    connectMode = { active: true, remove: true, source: null };
    setMessage(connectionMessage, "Modo BORRAR CONEXIÓN: clic en primer nodo → clic en segundo nodo", 5000);
  });

  // intercept clicks to implement connectMode, otherwise default to opening overlay
  network.on("click", params => {
    // if click on node(s) and connectMode active, handle it
    if (connectMode.active && params.nodes && params.nodes.length) {
      const clicked = params.nodes[0];
      if (!connectMode.source) {
        connectMode.source = clicked;
        setMessage(connectionMessage, `Origen seleccionado: ${clicked}. Ahora clic en destino.`, 3000);
      } else {
        const src = connectMode.source;
        const dst = clicked;
        if (src === dst) {
          setMessage(connectionMessage, "Origen y destino iguales. Cancelando modo conexión.", 1800);
          connectMode = { active: false, remove: false, source: null };
        } else {
          // ensure same constellation? allow cross-constellation connections if wanted.
          if (connectMode.remove) {
            const existing = edges.get({ filter: e => ( (e.from==src && e.to==dst) || (e.from==dst && e.to==src) ) });
            if (!existing.length) setMessage(connectionMessage, "No existe esa conexión.",1500);
            else { existing.forEach(e=>edges.remove(e.id)); setMessage(connectionMessage,"Conexión eliminada",1200); }
          } else {
            const existing = edges.get({ filter: e => ( (e.from==src && e.to==dst) || (e.from==dst && e.to==src) ) });
            if (existing.length) setMessage(connectionMessage, "Ya existe esa conexión.",1400);
            else { edges.add({ from: src, to: dst }); setMessage(connectionMessage, "Conexión creada ✓",1200); }
          }
          connectMode = { active: false, remove: false, source: null };
          persistAll();
        }
      }
      return; // stop further handling (avoid overlay focus)
    }

    // else -- if it's a node click open overlay (we already have network.on('selectNode') opening overlay)
    // default behavior handled elsewhere
  });

  // ---------- prevent auto-zoom loops ----------
  // We avoid calling network.focus or network.fit when creating nodes or edges.
  // Only use gentle fit on initial load once.
  let initialFitted = false;
  if (!initialFitted) {
    setTimeout(()=>{ try { network.moveTo({scale:1}); network.fit({animation:{duration:600}}); } catch(e){} }, 500);
    initialFitted = true;
  }

  // ---------- Export / Import / Reset ----------
  exportBtn.addEventListener("click", () => {
    const payload = { nodes: nodes.get(), edges: edges.get() };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = "constelaciones_export.json"; a.click();
    URL.revokeObjectURL(url);
  });

  importBtn.addEventListener("click", () => {
    const txt = prompt("Pegar JSON exportado:");
    if (!txt) return;
    try {
      const parsed = JSON.parse(txt);
      if (Array.isArray(parsed.nodes) && Array.isArray(parsed.edges)) {
        nodes.clear(); edges.clear();
        // normalize nodes
        const normNodes = parsed.nodes.map(n => {
          const copy = { ...n };
          if (copy.fixed === true) copy.fixed = { x: true, y: true };
          return copy;
        });
        nodes.add(normNodes);
        edges.add(parsed.edges);
        persistAll();
        refreshConstellationOptions();
        setMessage(storageMessage, "Importación OK", 2000);
      } else {
        setMessage(storageMessage, "JSON inválido", 2400);
      }
    } catch (e) {
      setMessage(storageMessage, "Error parseando JSON", 2400);
    }
  });

  resetBtn.addEventListener("click", () => {
    if (!confirm("¿Borrar todo y volver al estado inicial?")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  });

  // ---------- utility: clicking empty area deselects and closes overlay ----------
  container.addEventListener("click", (ev) => {
    // clicking background already handled by vis; but close overlay if clicked outside nodes
    // We guard so click on control elements don't trigger.
  });

  // ---------- small particle background (kept original) ----------
  const canvas = document.getElementById("particles");
  const ctx = canvas.getContext("2d", { alpha: true });
  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  function resizeCanvas() {
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  const N = 90;
  const parts = new Array(N).fill(0).map(() => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    vx: (Math.random() - 0.5) * 0.14 * DPR,
    vy: (Math.random() - 0.5) * 0.14 * DPR,
    r: (Math.random() * 1.2 + 0.6) * DPR
  }));

  function tick() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let i=0;i<N;i++){
      const a = parts[i];
      a.x += a.vx; a.y += a.vy;
      if (a.x < 0 || a.x > canvas.width) a.vx *= -1;
      if (a.y < 0 || a.y > canvas.height) a.vy *= -1;
      ctx.beginPath(); ctx.arc(a.x, a.y, a.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,230,210,0.55)"; ctx.fill();
      for (let j=i+1;j<N;j++){
        const b = parts[j];
        const dx = a.x-b.x, dy = a.y-b.y;
        const d2 = dx*dx+dy*dy; const max = 140*DPR;
        if (d2 < max*max) {
          const alpha = 1 - Math.sqrt(d2)/max;
          ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
          ctx.lineWidth = 0.8 * DPR; ctx.strokeStyle = `rgba(255,210,180,${0.12*alpha})`; ctx.stroke();
        }
      }
    }
    requestAnimationFrame(tick);
  }
  tick();

  // ---------- keyboard support: Esc to cancel connect mode and close overlay ----------
  document.addEventListener("keydown", e=> {
    if (e.key === "Escape") {
      connectMode = { active:false, remove:false, source:null };
      closeOverlay();
    }
  });

  // ---------- On first load, ensure constellations menu reflects groups present ----------
  refreshConstellationOptions();

  // done
  console.log("Constelaciones cargadas. Redes listas.");

  </script>
<!-- Botón e input para importar constelaciones -->
<input type="file" id="importFile" accept=".json" style="display:none;">
<button id="importButton" style="
  position:fixed;
  top:10px;
  right:10px;
  z-index:1000;
  background:rgba(0,0,0,0.6);
  color:white;
  border:none;
  border-radius:12px;
  padding:8px 14px;
  cursor:pointer;
  font-size:14px;
">Importar constelación</button>

<script>
const importButton = document.getElementById("importButton");
const importFile = document.getElementById("importFile");

importButton.addEventListener("click", () => importFile.click());

importFile.addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      loadConstellation(data);
    } catch (err) {
      alert("Error al leer el archivo JSON: " + err.message);
    }
  };
  reader.readAsText(file);
});

function loadConstellation(data) {
  // Elimina los nodos y líneas previas
  document.querySelectorAll(".node, .connection, .node-label").forEach(el => el.remove());

  // Accedemos al SVG existente
  const svg = document.querySelector("svg");
  const nodes = {};

  // Crear nuevos nodos
  data.nodos.forEach(nodo => {
    // Crear círculo
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", nodo.x);
    circle.setAttribute("cy", nodo.y);
    circle.setAttribute("r", nodo.radio || 10);
    circle.setAttribute("fill", nodo.color || "#ffffff");
    circle.classList.add("node");
    svg.appendChild(circle);

    // Crear texto
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", nodo.x + 15);
    text.setAttribute("y", nodo.y + 5);
    text.textContent = nodo.titulo;
    text.classList.add("node-label");
    svg.appendChild(text);

    // Guardar info para overlay y conexiones
    nodes[nodo.titulo] = { 
      element: circle,
      x: nodo.x, 
      y: nodo.y, 
      info: nodo.info || "Sin información disponible"
    };

    // Click para mostrar overlay
    circle.addEventListener("click", () => {
      const overlay = document.getElementById("overlay");
      const overlayTitle = document.getElementById("overlay-title");
      const overlayInfo = document.getElementById("overlay-info");
      overlayTitle.textContent = nodo.titulo;
      overlayInfo.textContent = nodo.info || "Sin información disponible";
      overlay.style.display = "flex";
    });
  });

  // Crear conexiones
  data.conexiones.forEach(([a, b]) => {
    if (nodes[a] && nodes[b]) {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", nodes[a].x);
      line.setAttribute("y1", nodes[a].y);
      line.setAttribute("x2", nodes[b].x);
      line.setAttribute("y2", nodes[b].y);
      line.setAttribute("stroke", "white");
      line.setAttribute("stroke-width", "1");
      line.classList.add("connection");
      svg.insertBefore(line, svg.firstChild);
    }
  });

  // Mover nodos adelante del resto
  document.querySelectorAll(".node").forEach(node => svg.appendChild(node));
  document.querySelectorAll(".node-label").forEach(label => svg.appendChild(label));
}
</script>
</body>
</html>


